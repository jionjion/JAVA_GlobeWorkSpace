并发:程序有多个线程,同时一个程序以不同状态执行时.
	多个线程操作相同的资源,保证线程安全
高并发:
	短时间内收到很多请求,提高程序性能
	
缓存一致性

java内存模型
	lock 	锁定,作用在主内存的变量,把一个变量标识为线程独占状态
	unlock	解锁,作用在主内存的变量,把一个变量释放,释放后的变量可以被其他线程锁定
	read	读取,作用在主内存的变量,把一个变量从主内存传输到线程的工作内存中,以便随后的load动作
	load	载入,作用在工作内存的变量,把read从主内存中得到的变量放到工作内存的变量副本中
	use		使用,作用在工作内存的变量,把工作内存中的一个变量值传递给执行引擎
	assign	赋值,作用在工作内存的变量,把一个从执行引擎中收到的值赋值给工作内存变量
	store	储存,作用在工作内存的变量,把工作内存中的一个变量的值传送到主内存中,以便随后的write的操作
	write	写入,作用在主内存的变量,把store从工作内存中得到的变量传递到主内存的变量中
	
同步规则
	- 如果把一个变量从主内存中复制到工作内存,就需要按顺序地执行read和load操作,如果把变量从工作内存中同步回主内存中,就要按顺序地执行
		stroe和write操作.但Java内存模型只要求上述操作必须顺序执行,而没有保证必须是连续执行.
	- 不允许read和load,store和write操作之一单独出现
	- 不允许一个线程丢弃它的最近assign的操作,即变量在工作内存中改变之后必须同步到主内存中
	- 不允许一个线程无原因,在未发生assign操作下,将数据从内存空间同步到主内存中
	- 一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化(load或assign)的变量.
		即在对一个变量执行use和store之前,必须执行了load和assign操作
	- 一个变量在同一时刻只允许一个线程对其进行lock操作,但lock操作可以被同一线程重复执行多次,多次lock之后,只有执行相同次数的unlock
		操作,变量才会被解锁.lock和unlock必须成对出现
	- 如果一个变量执行lock操作,将会清空工作内存中此变量的值,在执行引擎使用这个变量之前需要重新执行load或者assign操作初始化变量的值
	- 如果一个变量事先没有被lock操作锁定,则不允许对它执行unlock操作;也不允许unlock一个被其他线程锁定的变量
	- 对一个变量执行unlock操作之前,必须先把此变量同步到主内存中,执行store和write操作

线程安全
	原子性	提供了互斥访问,同一时刻只能有一个线程对它进行操作.
	可见性	一个线程对主内存的修改可以及时地被其他线程观察到
	有序性	一个线程观察到其他线程中的指令执行顺序. 由于指令的重排序存在,改观察结果一般是无序的

锁:
	synchronized关键字	在作用对象的作用范围内,同一时刻只能有一个线程进行修改,不会被继承.
						不可中断锁,适合竞争不激烈,可读性好
			修饰代码块		大括号包裹起来的代码块,作用于调用的对象
			修饰方法		整个方法,成为同步方法,作用于调用的对象
			修饰静态方法	整个静态方法,作用于该类的所有对象
			修饰类		括号括起来的部分,作用于所有对象
	Look接口				特殊的CPU指令,代码实现,如ReentrantLock类
						可中断锁,多样化同步,竞争激烈时能维持常态
	Atomic包				竞争激烈时能维持常态,比Lock性能好;只能同步一个值
	
可见性
	一个线程对共享变量的修改可以被其他线程检测到
	导致共享变量在线程间不可见的原因
		- 线程交叉执行
		- 重排序结合线程交叉执行
		- 共享变量更新后的值没有及时在工作内存和主内存之间及时更新
	
	内存模型中,synchronized的规定
		- 线程解锁前,必须把共享变量的值刷新到主内存中
		- 线程加锁时,将清空工作内存中共享变量的值,从而使用共享变量时需要从主内存中从新读取最新的值.
		
	volatile关键字		通过加入内存屏障和禁止重排序优化来实现,不能实现原子性,多用来修饰状态标识位 ture/false
		- 对volatile变量写操作时,会在写操作后加入一条store屏障指令,将本地内存的共享变量值刷新到主内存中
		- 对volatile变量读操作时,会在读操作前加入一条load屏障指令,从内存中读取共享变量.

有序性
	内存模型中,允许编译器和处理器对指令进行重排序,但是重排序过程不会影响到单线程程序的执行,却会影响到多线程编并发执行的正确性
	如果可以通过happens-before原则推导,则顺序执行;否则虚拟机可以随意排序
	
happens-before原则
	程序次序规则		一个线程内,按照代码顺序,书写在前面的操作先行发生于书写在后面的操作
	锁定规则			一个unlock操作线型发生于后面对同一个锁的lock操作
	volatile变量规则	一个变量的写操作先行发生于后面对这个变量的读操作
	传递规则			如果A操作先行于B操作,B操作先行于A操作,则A操作必先行于C操作
	线程启动规则		Thread对象的start()方法先行发生于此线程的每一个动作
	线程中断规则		对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
	线程终结规则		线程中所有的操作都先行发生于线程的终止检测,可以通过Thread.join()方法结束,Thread.isAlive()的返回值判断线程是否结束
	对象终结规则		一个对象的初始化完成先行发生于它的finalize()方法的开始
	
发布对象
	发布对象			使一个对象能够被当前范围之外的代码所使用
	对象溢出			一种错误的发布.当一个对象还未构建完成时,就使改对象被其他线程所见
	
安全发布对象
	- 在静态初始化函数中初始化一个对象引用
	- 将对象的引用保存到一个volatile类型域或者AtomicReference对象中
	- 将对象的引用保存到某个正确构造对象的final类型域中
	- 将对象的引用保存到一个由锁保护的域中

不可变对象
	- 对象创建后其状态不能修改
		使用final修饰类	类不会被继承,方法隐式为final
		使用final修饰方法	锁定方法不被继承类修改,一个private方法会被隐式修改为final方法
		使用final修饰变量	基本数据类型变量,不会被修改;引用类型,不会被指向其他对象,但对象仍可以改变属性
	- 对象所有的域都是final类型
		私有属性
	- 对象是正确创建的(在创建期间,this引用没有溢出)
		私有属性不提供set方法
	参考String类型
			
	使用 Collections.unmodifiableXXX:Collection,Lsit,Set,Map构建不可修改的类

线程封闭
	把对象封装到一个线程中,只允许单个线程访问
	- 堆栈封闭					使用局部变量(不是类变量),使每个线程在访问时单独拷贝一份到工作内存中,不会同时修改主内存的变量,无编发问题
							多数情况下,在类对象的方法声明的变量可构成线程封闭,实现线程安全
	- ThreadLocal线程封闭		通过内部维护的Map(key:线程名,value:变量)完成了对每一个线程中变量的维护
		
ThreadLocal线程储存信息
	1.创建静态方法类,使用ThreadLocal实例化要寄存在线程中的属性信息,并编写get/set/remove方法
	2.一般通过Filter拦截器,拦截调用某个方法的线程,并将数据信息放入线程中
	3.可以在控制层获得线程数据,进行业务处理
	3.编写Adapter方法,在方法结束后,将线程中的属性信息移除
	4.以上,注意Filter和Adapter在Web中的配置
		
线程不安全的类
	同一个类可以被多个线程同时修改,该类则为线程不安全的类
	
同步容器
	线程安全的集合框架类
	ArrayList中的Vector与Stack
	HashMap中的HashTable
	Collections.synchronizedXXX(List , Set , Map)

并发容器 J.U.C
	ArrayList中的CopyOnWriteArrayList
		首先将ArrayList拷贝一份,在拷贝中加锁,然后做各种修改,随后将引用指针指向新创建的ArrayList
		不能用于特别大的数组或者实时写入的值的保持最新
		虽然线程安全,但是效率偏低
	HashSet中的CopyOnWriteArraySet
		使用CopyOnWriteArrayList实现Set,适合与长度较小的元素
	TreeSet中的ConcurrentSkipListSet
		支持自定义排序
	HashMap中的ConcurrentHashMap
		适合高并发时
	TreeMap中的ConcurrentSkipListMap
		使用跳表数据结构,更适合高并发

常见共享对象线程安全策略
	线程限制	一个被线程限制的对象,由线程独占,并且只能被占有它的线程修改
	共享只读	一个共享只读的对象,在没有额外同步的情况下,可以被多个线程并发访问,但是任何线程都不能修改它
	线程对象	一个线程全的对象或者容器,在内部通过同步机制来保证线程安全,所以其他线程无需额外额同步就可以通过公共接口随意访问它
	被守护对象	被守护对象只能通过获取特殊的锁来进行访问9
		
并发容器中同步器 AQS
	采用继承方式实现模板中定义的方法
	可以实现排它锁和共享锁模式
同步组件
	CountDownLatch	通过一个计数,实现阻塞当前线程
				多用于并行计算,当结果获取后,继续执行其他任务
	Semaphore		信号量,控制同一时间并发线程的数量
				多用于有限访问的资源数量,限制并发访问数量
	CyclicBarrier	通过计数器控制线程等待,当计数器到达某一阈值后,被等待的线程才可以继续执行.可以被循环等待
				多用于实现多个线程之间相互等待
	ReentrantLock	锁
				注意:使用ReentrantLock类时,需要在finally语句块中解锁
	Condition		线程间相互通信的类,调度线程执行顺序
	BlockingQueue	阻塞队列,当队列满时,会将多余的线程进行阻塞
					ArrayBlockingQueue 	先进先出的方式进行,创建时指定大小
					DelayQueue			可排序的队列
					LinkedBlockingQueue	链表实现
					PriorityBlockingQueue 可以优先级排序的队列
					SynchronousQueue	同步队列,仅允许一个元素放入取出
				多用于生产者和消费者的关系
	
JDK实现异步/线程
Callable接口		进而调用线程执行	
Runnable接口		进行异步线程执行,并返回执行结果
Future接口		对Callable和Runnable进行监视,获得当前线程状态和返回值
FutureTask类		对其他线程监视,并获得返回结果做为本线程的处理

ReentrantLock锁与synchronized锁区别
	都是可重用锁
	synchronized依赖JVM实现,ReentrantLock依赖JDK实现
	推荐synchronized
	* ReentrantLock需要手动加锁和解锁,而synchronized只需要用关键字即可
	* ReentrantLock可以自定义是否为公平锁(先等待的线程先获得锁)
	* ReentrantLock可以使用Condition类,可以分组唤醒需要等待的线程
	* 提供能够中断等待锁的线程的机制,lock.lockInterruptibly()

Fork/Join框架
	将一个大的任务分隔为多个小的任务,最后再汇总为一个任务.

使用 new Thread的闭关
	每次使用new Thread新建对象,性能差
	线程缺乏统一管理,无限制的新建线程,导致竞争资源
	缺少更多功能,如执行,定期执行,线程终端
	
线程池
	重用线程,减少系统开销
	可以有效控制并发线程数,提高系统资源利用率,同时可以避免过多资源竞争,避免阻塞
	提供定期执行,定期执行,单线程,并发数控制

ThreadPoolExecutor	线程池参数
	corePoolSize	核心线程数量
	maximumPoolSize	线程最大线程数
	workQueue		阻塞队列,储存等执行的任务
	keepAliveTime	线程没有任务执行时,最多保持多久时间销毁
	unit			keepAliveTime的时间单位,TimeUnit
	threadFactory	线程工厂
	rejectHandler	拒绝处理任务时的策略,RejectedExecutionHandler
					- 抛出异常
					- 调用者的线程完成任务
					- 丢弃队列中最靠前的任务
					- 丢弃当前任务
				
线程池状态
	running			运行状态,可以提交并运行线程任务
	shutdown		关闭状态,不能提交新任务,但是可以处理阻塞线程中的任务
	stop			中断状态,终止运行中的任务. shutdownNow()
	tidying			关闭
	terminated		销毁

线程池方法
	execute()		提交任务,交给线程池执行
	submit()		提交任务,返回执行结果   execute + future
	shutdown()		等待任务执行完后关闭
	shutdownNow()	终止,立即关闭线程池,停止所有线程
	getTaskCount()	线程池已经执行和未执行的任务总数
	getCompletedTaskCount()	已经完成的任务数量
	getPoolSize()	线程池当前的线程数量
	getActiveCount()当前线程池中正在执行任务的线程数量
	
线程池种类
	Executors.newCacheThreadPool	创建可以缓存的线程池,灵活创建和回收线程	
	Executors.newFixedThreadPool	创建定长的线程池,控制并发数量,超出线程在队列中等待
	Executors.newScheduledThreadPool创建定长的线程池,周期定时执行
	Executors.newSingleThreadExecutor创建单线程化的线程,按照指定顺序进行执行
	
死锁
	多个线程为了争夺相同资源而造成的相互等待现象
发生条件
	- 互斥条件,资源的使用是互斥的
	- 不剥夺条件,获得资源后不会被剥夺,只有自己使用完后释放
	- 请求和保持条件
	- 环路等待条件

多线程的实践
	- 尽量使用本地变量
	- 使用不可变类
	- 最小化锁的作用域范围
	- 使用线程池的Executor方法,而不是创建线程
	- 使用同步而不是线程的wait和notify方法
	- 使用BlockingQueue实现生产-消费模式
	- 使用并发集合而不是加了锁的同步集合
	- 使用Semaphore创建有界的访问
	- 多使用同步代码块,而不是是同步的方法
	- 避免会用静态变量

Spring的线程安全
	设计合适的Bean生命周期,singleton , prototype
	无状态的bean的引用,使Spring线程安全
	
缓存穿透
	在缓存对象为空时,将对象置为空对象
缓存更新
	在缓存更新时,为其加锁,避免其他线程同步操作






















	