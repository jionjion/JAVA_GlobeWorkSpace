内存可见性

	可见性:	一个线程对共享变量值的修改,能够及时地被其他线程看到,则该变量为可见的
	共享变量:	如果一个变量在多个线程的工作内存中都存在副本,那么这个变量就是这几个线程的共享变量
	
	Java内存模型:描述了java程序中各种共享变量(线程共享变量)的访问规则,以及在JVM中将共享变量储存到内存
		和从内存中读取出共享变量这样的底层细节.
	
	主内存:	所有的变量都储存在主内存中
	工作内存:	每个线程都有自己的独立的工作内存,里面保存该线程使用的变量副本(主内存中该变量的一份拷贝)
	
	规则:
		线程对共享变量的所有操作都必须在自己的工作内存中进行,不能直接从主内存中进行读写
		不同线程之间无法直接访问其他线程工作内存中的变量,线程间变量值的传递需要通过主内存完成
		
	
	共享变量可见性的实现:	
		把工作内存1中的值刷新到主内存中,再把主内存中变更的值刷新到工作内存2中
		
	实现的条件:
		线程修改后的共享变量值能够及时从工作内存刷新到主内存中
		其他线程能够及时把共享变量的最新值从主内存中刷新到自己的工作内存中
	实现的方式:
		synchronized:同步,实现步骤锁,保证同一时刻只能有一个修改
			线程解锁前,必须把共享变量的最新值刷新到主内存中
			线程加锁前,将清空工作内存中共享变量的值,从而使用共享变量时需要从主内存中重新读取最新的值
			获得互斥锁->清空工作内存->主内存拷贝最新副本到工作内存->执行代码->将更改后的共享变量刷新到主内存->释放互斥锁
			
		volatile:
	
	重排序:代码书写顺序与实际执行顺序不同,指令重排序是为了提高程序性能而做出的优化
		1.编译器优化的重排序(编译器优化)
		2.指令级并行重排序(处理器优化)
		3.内存系统的重排序(处理器优化)
	
	as-if-serial:无论如何重排序,程序执行的结果应该与代码顺序执行的结果一直(单线程下遵循如此)
		