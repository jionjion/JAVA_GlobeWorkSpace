# 设计模式

## 核心原则

### 单一职责
一个类/方法只负责一个职责.

### 接口隔离
客户端不应该依赖它不需要的接口; 
如:当一个接口定义过多方法时,其调用者们可能不会用到全部方法,则需要将一个大接口按照方法进行分组拆分为多个小接口,以便降低隔离.

### 依赖倒转
1. 高层模块不应该依赖低层模块,二者都因该依赖 **抽象** .
2. 抽象不应该依赖细节,细节应该依赖抽象.如:在Service层依赖Dao层接口,而非实现.
3. 依赖倒转的中心思想是 **面向接口编程** .如:声明接口及其实现,通过调用接口而非实现.
4. 抽象比具体更稳固,代码变动少.
5. 使用接口/抽象制定规范,而不涉及到具体的任何操作.

依赖传递:
- 接口传递:在调用处传递接口作为方法参数.
- 构造方法传递:在构造方法中,传递接口作为构造参数
- setter方法传递:调用setter方法,传递接口作为类的成员变量

### 里式替换
在子类中尽量不要重写父类方法;
而是通过抽取相同类的共有方法提取到父类,通过组合(component),实现调用相同类之间的依赖

### 开闭原则
1. 对扩展放开发(提供方),对使修改关闭(调用方).
2. 当软件变化时,通过扩展软件而实现变化,而不是修改原有代码.
如: 接口定义和具体的实现类.

### 迪米特法则
一个类对自己依赖的类知道的越少越好.即:将内部逻辑封装,对外提供(public)方法

### 合成复用
尽量使用组合/聚合的方式,而不是继承方式
组合: 强制依赖的类关系.
聚合: 松依赖的类关系.

## 设计模式分类
- 创建型
单例模式 / 工厂模式 / 抽象工厂模式 / 原型模式 / 建造者模式 / 工厂模式
- 结构型
适配器模式 / 桥接模式 / 装饰器模式 / 组合模式 / 外观模式 / 享元模式 / 代理模式
- 行为型
模板方法模式 / 命令模式 / 访问者模式 / 迭代器模式 / 观察者模式 / 中介者模式 / 备忘录模式 / 解释器模式 / 状态模式 / 策略模式 / 责任链模式
